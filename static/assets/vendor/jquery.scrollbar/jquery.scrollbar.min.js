/**
 * jQuery CSS Customizable Scrollbar
 *
 * Copyright 2015, Yuriy Khabarov
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * If you found bug, please contact me via email <13real008@gmail.com>
 *
 * Compressed by http://jscompress.com/
 *
 * @author Yuriy Khabarov aka Gromo
 * @version 0.2.11
 * @url https://github.com/gromo/jquery.scrollbar/
 *
 */
!(function(a, b) {
  typeof define === 'function' && define.amd
    ? define(['jquery'], b)
    : b(typeof exports !== 'undefined' ? require('jquery') : a.jQuery)
})(this, function(a) {
  'use strict'
  function h(b) {
    if (c.webkit && !b) return { height: 0, width: 0 }
    if (!c.data.outer) {
      const d = {
        border: 'none',
        'box-sizing': 'content-box',
        height: '200px',
        margin: '0',
        padding: '0',
        width: '200px'
      }
      ;(c.data.inner = a('<div>').css(a.extend({}, d))),
        (c.data.outer = a('<div>')
          .css(
            a.extend(
              {
                left: '-1000px',
                overflow: 'scroll',
                position: 'absolute',
                top: '-1000px'
              },
              d
            )
          )
          .append(c.data.inner)
          .appendTo('body'))
    }
    return (
      c.data.outer.scrollLeft(1e3).scrollTop(1e3),
      {
        height: Math.ceil(
          c.data.outer.offset().top - c.data.inner.offset().top || 0
        ),
        width: Math.ceil(
          c.data.outer.offset().left - c.data.inner.offset().left || 0
        )
      }
    )
  }
  function i() {
    const a = h(!0)
    return !(a.height || a.width)
  }
  function j(a) {
    const b = a.originalEvent
    return (!b.axis || b.axis !== b.HORIZONTAL_AXIS) && !b.wheelDeltaX
  }
  const b = !1
  var c = {
    data: { index: 0, name: 'scrollbar' },
    firefox: /firefox/i.test(navigator.userAgent),
    macosx: /mac/i.test(navigator.platform),
    msedge: /edge\/\d+/i.test(navigator.userAgent),
    msie: /(msie|trident)/i.test(navigator.userAgent),
    mobile: /android|webos|iphone|ipad|ipod|blackberry/i.test(
      navigator.userAgent
    ),
    overlay: null,
    scroll: null,
    scrolls: [],
    webkit:
      /webkit/i.test(navigator.userAgent) &&
      !/edge\/\d+/i.test(navigator.userAgent)
  }
  ;(c.scrolls.add = function(a) {
    this.remove(a).push(a)
  }),
    (c.scrolls.remove = function(b) {
      for (; a.inArray(b, this) >= 0; ) this.splice(a.inArray(b, this), 1)
      return this
    })
  const d = {
    autoScrollSize: !0,
    autoUpdate: !0,
    debug: !1,
    disableBodyScroll: !1,
    duration: 200,
    ignoreMobile: !1,
    ignoreOverlay: !1,
    isRtl: !1,
    scrollStep: 30,
    showArrows: !1,
    stepScrolling: !0,
    scrollx: null,
    scrolly: null,
    onDestroy: null,
    onFallback: null,
    onInit: null,
    onScroll: null,
    onUpdate: null
  }
  const e = function(b) {
    c.scroll ||
      ((c.overlay = i()),
      (c.scroll = h()),
      g(),
      a(window).resize(function() {
        let a = !1
        if (c.scroll && (c.scroll.height || c.scroll.width)) {
          const b = h()
          ;(b.height === c.scroll.height && b.width === c.scroll.width) ||
            ((c.scroll = b), (a = !0))
        }
        g(a)
      })),
      (this.container = b),
      (this.namespace = '.scrollbar_' + c.data.index++),
      (this.options = a.extend({}, d, window.jQueryScrollbarOptions || {})),
      (this.scrollTo = null),
      (this.scrollx = {}),
      (this.scrolly = {}),
      b.data(c.data.name, this),
      c.scrolls.add(this)
  }
  e.prototype = {
    destroy() {
      if (this.wrapper) {
        this.container.removeData(c.data.name), c.scrolls.remove(this)
        const b = this.container.scrollLeft()
        const d = this.container.scrollTop()
        this.container
          .insertBefore(this.wrapper)
          .css({ height: '', margin: '', 'max-height': '' })
          .removeClass(
            'scroll-content scroll-scrollx_visible scroll-scrolly_visible'
          )
          .off(this.namespace)
          .scrollLeft(b)
          .scrollTop(d),
          this.scrollx.scroll
            .removeClass('scroll-scrollx_visible')
            .find('div')
            .addBack()
            .off(this.namespace),
          this.scrolly.scroll
            .removeClass('scroll-scrolly_visible')
            .find('div')
            .addBack()
            .off(this.namespace),
          this.wrapper.remove(),
          a(document)
            .add('body')
            .off(this.namespace),
          a.isFunction(this.options.onDestroy) &&
            this.options.onDestroy.apply(this, [this.container])
      }
    },
    init(b) {
      const d = this
      const e = this.container
      let f = this.containerWrapper || e
      const g = this.namespace
      const h = a.extend(this.options, b || {})
      const i = { x: this.scrollx, y: this.scrolly }
      let k = this.wrapper
      let l = {}
      const m = { scrollLeft: e.scrollLeft(), scrollTop: e.scrollTop() }
      if (
        (c.mobile && h.ignoreMobile) ||
        (c.overlay && h.ignoreOverlay) ||
        (c.macosx && !c.webkit)
      )
        return a.isFunction(h.onFallback) && h.onFallback.apply(this, [e]), !1
      if (k)
        (l = {
          height: 'auto',
          'margin-bottom': c.scroll.height * -1 + 'px',
          'max-height': ''
        }),
          (l[h.isRtl ? 'margin-left' : 'margin-right'] =
            c.scroll.width * -1 + 'px'),
          f.css(l)
      else {
        if (
          ((this.wrapper = k = a('<div>')
            .addClass('scroll-wrapper')
            .addClass(e.attr('class'))
            .css(
              'position',
              e.css('position') === 'absolute' ? 'absolute' : 'relative'
            )
            .insertBefore(e)
            .append(e)),
          h.isRtl && k.addClass('scroll--rtl'),
          e.is('textarea') &&
            ((this.containerWrapper = f = a('<div>')
              .insertBefore(e)
              .append(e)),
            k.addClass('scroll-textarea')),
          (l = {
            height: 'auto',
            'margin-bottom': c.scroll.height * -1 + 'px',
            'max-height': ''
          }),
          (l[h.isRtl ? 'margin-left' : 'margin-right'] =
            c.scroll.width * -1 + 'px'),
          f.addClass('scroll-content').css(l),
          e.on('scroll' + g, function(b) {
            let f = e.scrollLeft()
            const g = e.scrollTop()
            if (h.isRtl)
              switch (!0) {
                case c.firefox:
                  f = Math.abs(f)
                case c.msedge || c.msie:
                  f = e[0].scrollWidth - e[0].clientWidth - f
              }
            a.isFunction(h.onScroll) &&
              h.onScroll.call(
                d,
                {
                  maxScroll: i.y.maxScrollOffset,
                  scroll: g,
                  size: i.y.size,
                  visible: i.y.visible
                },
                {
                  maxScroll: i.x.maxScrollOffset,
                  scroll: f,
                  size: i.x.size,
                  visible: i.x.visible
                }
              ),
              i.x.isVisible && i.x.scroll.bar.css('left', f * i.x.kx + 'px'),
              i.y.isVisible && i.y.scroll.bar.css('top', g * i.y.kx + 'px')
          }),
          k.on('scroll' + g, function() {
            k.scrollTop(0).scrollLeft(0)
          }),
          h.disableBodyScroll)
        ) {
          const n = function(a) {
            j(a)
              ? i.y.isVisible && i.y.mousewheel(a)
              : i.x.isVisible && i.x.mousewheel(a)
          }
          k.on('MozMousePixelScroll' + g, n),
            k.on('mousewheel' + g, n),
            c.mobile &&
              k.on('touchstart' + g, function(b) {
                const c =
                  (b.originalEvent.touches && b.originalEvent.touches[0]) || b
                const d = { pageX: c.pageX, pageY: c.pageY }
                const f = { left: e.scrollLeft(), top: e.scrollTop() }
                a(document).on('touchmove' + g, function(a) {
                  const b =
                    (a.originalEvent.targetTouches &&
                      a.originalEvent.targetTouches[0]) ||
                    a
                  e.scrollLeft(f.left + d.pageX - b.pageX),
                    e.scrollTop(f.top + d.pageY - b.pageY),
                    a.preventDefault()
                }),
                  a(document).on('touchend' + g, function() {
                    a(document).off(g)
                  })
              })
        }
        a.isFunction(h.onInit) && h.onInit.apply(this, [e])
      }
      a.each(i, function(b, f) {
        let k = null
        let l = 1
        const m = b === 'x' ? 'scrollLeft' : 'scrollTop'
        let n = h.scrollStep
        const o = function() {
          let a = e[m]()
          e[m](a + n),
            l == 1 && a + n >= p && (a = e[m]()),
            l == -1 && a + n <= p && (a = e[m]()),
            e[m]() == a && k && k()
        }
        var p = 0
        f.scroll ||
          ((f.scroll = d._getScroll(h['scroll' + b]).addClass('scroll-' + b)),
          h.showArrows && f.scroll.addClass('scroll-element_arrows_visible'),
          (f.mousewheel = function(a) {
            if (!f.isVisible || (b === 'x' && j(a))) return !0
            if (b === 'y' && !j(a)) return i.x.mousewheel(a), !0
            let c = a.originalEvent.wheelDelta * -1 || a.originalEvent.detail
            const g = f.size - f.visible - f.offset
            return (
              c ||
                (b === 'x' && a.originalEvent.deltaX
                  ? (c = 40 * a.originalEvent.deltaX)
                  : b === 'y' &&
                    a.originalEvent.deltaY &&
                    (c = 40 * a.originalEvent.deltaY)),
              ((c > 0 && p < g) || (c < 0 && p > 0)) &&
                ((p += c),
                p < 0 && (p = 0),
                p > g && (p = g),
                (d.scrollTo = d.scrollTo || {}),
                (d.scrollTo[m] = p),
                setTimeout(function() {
                  d.scrollTo &&
                    (e.stop().animate(d.scrollTo, 240, 'linear', function() {
                      p = e[m]()
                    }),
                    (d.scrollTo = null))
                }, 1)),
              a.preventDefault(),
              !1
            )
          }),
          f.scroll
            .on('MozMousePixelScroll' + g, f.mousewheel)
            .on('mousewheel' + g, f.mousewheel)
            .on('mouseenter' + g, function() {
              p = e[m]()
            }),
          f.scroll
            .find('.scroll-arrow, .scroll-element_track')
            .on('mousedown' + g, function(g) {
              if (g.which != 1) return !0
              l = 1
              const i = {
                eventOffset: g[b === 'x' ? 'pageX' : 'pageY'],
                maxScrollValue: f.size - f.visible - f.offset,
                scrollbarOffset: f.scroll.bar.offset()[
                  b === 'x' ? 'left' : 'top'
                ],
                scrollbarSize: f.scroll.bar[
                  b === 'x' ? 'outerWidth' : 'outerHeight'
                ]()
              }
              let j = 0
              let q = 0
              if (a(this).hasClass('scroll-arrow')) {
                if (
                  ((l = a(this).hasClass('scroll-arrow_more') ? 1 : -1),
                  (n = h.scrollStep * l),
                  (p = l > 0 ? i.maxScrollValue : 0),
                  h.isRtl)
                )
                  switch (!0) {
                    case c.firefox:
                      p = l > 0 ? 0 : i.maxScrollValue * -1
                      break
                    case c.msie || c.msedge:
                  }
              } else (l = i.eventOffset > i.scrollbarOffset + i.scrollbarSize ? 1 : i.eventOffset < i.scrollbarOffset ? -1 : 0), b === 'x' && h.isRtl && (c.msie || c.msedge) && (l *= -1), (n = Math.round(0.75 * f.visible) * l), (p = i.eventOffset - i.scrollbarOffset - (h.stepScrolling ? (l == 1 ? i.scrollbarSize : 0) : Math.round(i.scrollbarSize / 2))), (p = e[m]() + p / f.kx)
              return (
                (d.scrollTo = d.scrollTo || {}),
                (d.scrollTo[m] = h.stepScrolling ? e[m]() + n : p),
                h.stepScrolling &&
                  ((k = function() {
                    ;(p = e[m]()),
                      clearInterval(q),
                      clearTimeout(j),
                      (j = 0),
                      (q = 0)
                  }),
                  (j = setTimeout(function() {
                    q = setInterval(o, 40)
                  }, h.duration + 100))),
                setTimeout(function() {
                  d.scrollTo &&
                    (e.animate(d.scrollTo, h.duration), (d.scrollTo = null))
                }, 1),
                d._handleMouseDown(k, g)
              )
            }),
          f.scroll.bar.on('mousedown' + g, function(i) {
            if (i.which != 1) return !0
            const j = i[b === 'x' ? 'pageX' : 'pageY']
            const k = e[m]()
            return (
              f.scroll.addClass('scroll-draggable'),
              a(document).on('mousemove' + g, function(a) {
                let d = parseInt(
                  (a[b === 'x' ? 'pageX' : 'pageY'] - j) / f.kx,
                  10
                )
                b === 'x' && h.isRtl && (c.msie || c.msedge) && (d *= -1),
                  e[m](k + d)
              }),
              d._handleMouseDown(function() {
                f.scroll.removeClass('scroll-draggable'), (p = e[m]())
              }, i)
            )
          }))
      }),
        a.each(i, function(a, b) {
          const c = 'scroll-scroll' + a + '_visible'
          const d = a == 'x' ? i.y : i.x
          b.scroll.removeClass(c), d.scroll.removeClass(c), f.removeClass(c)
        }),
        a.each(i, function(b, c) {
          a.extend(
            c,
            b == 'x'
              ? {
                  offset: parseInt(e.css('left'), 10) || 0,
                  size: e.prop('scrollWidth'),
                  visible: k.width()
                }
              : {
                  offset: parseInt(e.css('top'), 10) || 0,
                  size: e.prop('scrollHeight'),
                  visible: k.height()
                }
          )
        }),
        this._updateScroll('x', this.scrollx),
        this._updateScroll('y', this.scrolly),
        a.isFunction(h.onUpdate) && h.onUpdate.apply(this, [e]),
        a.each(i, function(a, b) {
          const c = a === 'x' ? 'left' : 'top'
          const d = a === 'x' ? 'outerWidth' : 'outerHeight'
          const f = a === 'x' ? 'width' : 'height'
          const g = parseInt(e.css(c), 10) || 0
          const i = b.size
          const j = b.visible + g
          const k =
            b.scroll.size[d]() + (parseInt(b.scroll.size.css(c), 10) || 0)
          h.autoScrollSize &&
            ((b.scrollbarSize = parseInt((k * j) / i, 10)),
            b.scroll.bar.css(f, b.scrollbarSize + 'px')),
            (b.scrollbarSize = b.scroll.bar[d]()),
            (b.kx = (k - b.scrollbarSize) / (i - j) || 1),
            (b.maxScrollOffset = i - j)
        }),
        e
          .scrollLeft(m.scrollLeft)
          .scrollTop(m.scrollTop)
          .trigger('scroll')
    },
    _getScroll(b) {
      const c = {
        advanced: [
          '<div class="scroll-element">',
          '<div class="scroll-element_corner"></div>',
          '<div class="scroll-arrow scroll-arrow_less"></div>',
          '<div class="scroll-arrow scroll-arrow_more"></div>',
          '<div class="scroll-element_outer">',
          '<div class="scroll-element_size"></div>',
          '<div class="scroll-element_inner-wrapper">',
          '<div class="scroll-element_inner scroll-element_track">',
          '<div class="scroll-element_inner-bottom"></div>',
          '</div>',
          '</div>',
          '<div class="scroll-bar">',
          '<div class="scroll-bar_body">',
          '<div class="scroll-bar_body-inner"></div>',
          '</div>',
          '<div class="scroll-bar_bottom"></div>',
          '<div class="scroll-bar_center"></div>',
          '</div>',
          '</div>',
          '</div>'
        ].join(''),
        simple: [
          '<div class="scroll-element">',
          '<div class="scroll-element_outer">',
          '<div class="scroll-element_size"></div>',
          '<div class="scroll-element_track"></div>',
          '<div class="scroll-bar"></div>',
          '</div>',
          '</div>'
        ].join('')
      }
      return (
        c[b] && (b = c[b]),
        b || (b = c.simple),
        (b = typeof b === 'string' ? a(b).appendTo(this.wrapper) : a(b)),
        a.extend(b, {
          bar: b.find('.scroll-bar'),
          size: b.find('.scroll-element_size'),
          track: b.find('.scroll-element_track')
        }),
        b
      )
    },
    _handleMouseDown(b, c) {
      const d = this.namespace
      return (
        a(document).on('blur' + d, function() {
          a(document)
            .add('body')
            .off(d),
            b && b()
        }),
        a(document).on('dragstart' + d, function(a) {
          return a.preventDefault(), !1
        }),
        a(document).on('mouseup' + d, function() {
          a(document)
            .add('body')
            .off(d),
            b && b()
        }),
        a('body').on('selectstart' + d, function(a) {
          return a.preventDefault(), !1
        }),
        c && c.preventDefault(),
        !1
      )
    },
    _updateScroll(b, d) {
      const e = this.container
      const f = this.containerWrapper || e
      const g = 'scroll-scroll' + b + '_visible'
      const h = b === 'x' ? this.scrolly : this.scrollx
      const i =
        parseInt(this.container.css(b === 'x' ? 'left' : 'top'), 10) || 0
      const j = this.wrapper
      const k = d.size
      const l = d.visible + i
      ;(d.isVisible = k - l > 1),
        d.isVisible
          ? (d.scroll.addClass(g), h.scroll.addClass(g), f.addClass(g))
          : (d.scroll.removeClass(g),
            h.scroll.removeClass(g),
            f.removeClass(g)),
        b === 'y' &&
          (e.is('textarea') || k < l
            ? f.css({
                height: l + c.scroll.height + 'px',
                'max-height': 'none'
              })
            : f.css({ 'max-height': l + c.scroll.height + 'px' })),
        (d.size == e.prop('scrollWidth') &&
          h.size == e.prop('scrollHeight') &&
          d.visible == j.width() &&
          h.visible == j.height() &&
          d.offset == (parseInt(e.css('left'), 10) || 0) &&
          h.offset == (parseInt(e.css('top'), 10) || 0)) ||
          (a.extend(this.scrollx, {
            offset: parseInt(e.css('left'), 10) || 0,
            size: e.prop('scrollWidth'),
            visible: j.width()
          }),
          a.extend(this.scrolly, {
            offset: parseInt(e.css('top'), 10) || 0,
            size: this.container.prop('scrollHeight'),
            visible: j.height()
          }),
          this._updateScroll(b === 'x' ? 'y' : 'x', h))
    }
  }
  const f = e
  ;(a.fn.scrollbar = function(b, d) {
    return (
      typeof b !== 'string' && ((d = b), (b = 'init')),
      typeof d === 'undefined' && (d = []),
      a.isArray(d) || (d = [d]),
      this.not('body, .scroll-wrapper').each(function() {
        const e = a(this)
        let g = e.data(c.data.name)
        ;(g || b === 'init') && (g || (g = new f(e)), g[b] && g[b].apply(g, d))
      }),
      this
    )
  }),
    (a.fn.scrollbar.options = d)
  var g = (function() {
    let a = 0
    let d = 0
    return function(e) {
      let f, h, i, j, k, l, m
      for (f = 0; f < c.scrolls.length; f++)
        (j = c.scrolls[f]),
          (h = j.container),
          (i = j.options),
          (k = j.wrapper),
          (l = j.scrollx),
          (m = j.scrolly),
          (e ||
            (i.autoUpdate &&
              k &&
              k.is(':visible') &&
              (h.prop('scrollWidth') != l.size ||
                h.prop('scrollHeight') != m.size ||
                k.width() != l.visible ||
                k.height() != m.visible))) &&
            (j.init(),
            i.debug &&
              (window.console &&
                console.log(
                  {
                    scrollHeight: h.prop('scrollHeight') + ':' + j.scrolly.size,
                    scrollWidth: h.prop('scrollWidth') + ':' + j.scrollx.size,
                    visibleHeight: k.height() + ':' + j.scrolly.visible,
                    visibleWidth: k.width() + ':' + j.scrollx.visible
                  },
                  !0
                ),
              d++))
      b && d > 10
        ? (window.console && console.log('Scroll updates exceed 10'),
          (g = function() {}))
        : (clearTimeout(a), (a = setTimeout(g, 300)))
    }
  })()
  window.angular &&
    !(function(a) {
      a.module('jQueryScrollbar', [])
        .provider('jQueryScrollbar', function() {
          const b = d
          return {
            setOptions(c) {
              a.extend(b, c)
            },
            $get() {
              return { options: a.copy(b) }
            }
          }
        })
        .directive('jqueryScrollbar', [
          'jQueryScrollbar',
          '$parse',
          function(a, b) {
            return {
              restrict: 'AC',
              link(c, d, e) {
                const f = b(e.jqueryScrollbar)
                const g = f(c)
                d.scrollbar(g || a.options).on('$destroy', function() {
                  d.scrollbar('destroy')
                })
              }
            }
          }
        ])
    })(window.angular)
})
